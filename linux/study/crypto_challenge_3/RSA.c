#include <stdio.h>
#include <stdlib.h>
#include <gmp.h>
#include <math.h>

#define MAX 160

int main(int argc, char* argv[])
{
	mpz_t buf, check, C, n, M, F;
	mpz_inits(buf, check, C, n, M, NULL);
	mpz_set_str(C, "374015834710561043810344051134135" , 10);
	mpz_set_str(n, "98639350158287747956171614024858003106737929785723376047985588489903225031675238942280563373940905701931651170379361219551278894213021434648783114473246721338107200738833103695814346217200966617698677137725683746838186561756004241774294434212453862492176950276330700287348945941127494562176214125995218765677", 10);
	mpz_set_str(M, ",8684345636908686698383058753930515845376216074491905095625386038921316376845905096948974184280037158397773209920391529649784574906985754450477350014610356222003127212466169135522169279492231954962510144676909892095883819057606351964935618910468692572435658048566378696492965708241737271579660195263078472751", 10);

	// 암호문 C, 개인키 d, 공개키 n, 정상평문 M

	int base, d=0;
	int i,j;
	char tmp[1000];
	int k[] = 
	{ 0, 5, 11, 18, 24, 30, 37, 43, 51, 57, 63, 70, 78, 84, 90, 98, 105, 112, 120, 125, 131, 137, 144, 150, 156, 161, 169, 176, 180, 187, 193, 201, 205, 212, 220, 228, 235, 239, 246, 252, 258, 265, 269, 277, 283, 290, 295, 301, 307, 311, 318, 326, 330, 337, 345, 353, 360, 365, 370, 377, 383, 389, 397, 405, 409, 413, 421, 429, 433, 441, 446, 454, 461, 468, 476, 483, 490, 497, 504, 510, 517, 524, 531, 538, 546, 551, 559, 562, 569, 577, 584, 590, 596, 599, 606, 609, 617, 624, 631, 638, 642, 648, 653, 658, 662, 670, 676, 681, 689, 693, 700, 708, 716, 723, 730, 738, 746, 753, 758, 763, 769, 778, 784, 790, 796, 804, 812, 819, 826, 831, 838, 844, 850, 858, 865, 869, 876, 883, 890, 897, 903, 910, 917, 925, 932, 939, 945, 950, 954, 959, 963, 969, 976, 983, 989, 993, 998, 1005, 1010, 1016, 1021 };	
	FILE *fd;

	fd = fopen("fault_message.txt", "r");
	if(fd == NULL)
	{
		printf("file non exist\n");
		exit(1);
	}
	i=1;
	d=k[0];
	do
	{
		// fd에서 F에 넣을값 가져오기 
		fgets(tmp, 1000, fd);
		mpz_set_str(F, tmp, 10);
		// F(n)


		//C^(k1~k2)
		j=0;
		
		do
		{


			mpz_pow_ui(buf, C, d+pow(2,k[i-1]+j++)-1); // buf = C^(base + 2^(k1~k2-1))
			mpz_add(buf, buf, F); // buf = buf + F
			mpz_mod(buf, buf, n); // buf = buf % n (moduler)
		      	
			if(j>pow(2,k[i]-1))
			{
				printf("****error****\n");
				exit(2);
			}
		} while(mpz_cmp(buf, M) == 0); // buf == M
		d=d+k[i-1]+j;
		/*
		 * 10110101010 <-최종목적d일경우 이를 모르는상태에서
		 * k1=3
		 * 10110101000 <-하위3bit 0으로 setting
		 * 3bit 의 경우의 수 d=0~2^3-1 중
		 * M == (F+C^(경우의수))mod n을 만족시킬때까지 loof
		 * 구하면 d+=d;
		 * k2=5
		 * 10110100000+d = 10110100111
		 * k2-k1의 위치에 해당하는 비트만 0이 setting되고 다시 경우의 수를 search
		 */
	}while(i++<MAX);


	printf("\n######end######\n");
	mpz_clears(buf, check, C, n, M,  NULL);
	fclose(fd);
	return 0;
}


